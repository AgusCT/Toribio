<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Reference</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Toribio</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Data_logger">Data logger</a></li>
<li><a href="#Remote_controlled_robot">Remote controlled robot</a></li>
<li><a href="#Reactive_line_follower">Reactive line follower</a></li>
</ul>


<h2>Topics</h2>
<ul>
  <li><a href="../topics/0-Installation.md.html">0-Installation.md</a></li>
  <li><strong>1-Tutorial.md</strong></li>
  <li><a href="../topics/2-Configuration.md.html">2-Configuration.md</a></li>
  <li><a href="../topics/3-Tasks.md.html">3-Tasks.md</a></li>
  <li><a href="../topics/4-Devices.md.html">4-Devices.md</a></li>
  <li><a href="../topics/README.md.html">README.md</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/bobot.html">bobot</a></li>
  <li><a href="../modules/dynamixel-bus.html">dynamixel-bus</a></li>
  <li><a href="../modules/dynamixel-motor.html">dynamixel-motor</a></li>
  <li><a href="../modules/mice.html">mice</a></li>
  <li><a href="../modules/toribio.html">toribio</a></li>
</ul>
<h2>Scripts</h2>
<ul>
  <li><a href="../scripts/toribio-go.html">toribio-go</a></li>
</ul>

</div>

<div id="content">

<h1>Topic <code>1-Tutorial.md</code></h1>

    
<h1>Tutorial.</h1>

<p>Here we will build a few programs, step-by-step.</p>


<p><a name="Data_logger"></a></p>
<h2>Data logger</h2>

<p>First we will do a data logger, that will save information read from an AX-12 motor to a file. We will call the task "axlogger".</p>

<p>We start by editing the configuration file. We must configure two things: enable the dynamixel device loader,
and register the new task, adding the configuration parameters we might use. We do that by adding the following lines to toribio-go.conf:</p>


<pre>
 deviceloaders.dynamixel.<span class="global">load</span> = <span class="keyword">true</span>
 deviceloaders.dynamixel.filename = <span class="string">'/dev/ttyUSB0'</span>
 tasks.axlogger.<span class="global">load</span>=<span class="keyword">true</span>
 tasks.axlogger.motorname=<span class="string">'ax12:3'</span>
 tasks.axlogger.interval=<span class="number">1</span>
 tasks.axlogger.outfile=<span class="string">'motor.log'</span>
</pre>

<p>Then we place the task's code in the tasks/ folder. The tasks/axlogger.lua file:</p>


<pre>
 <span class="keyword">local</span> M = {}
 <span class="keyword">local</span> sched=<span class="global">require</span> <span class="string">'sched'</span>
 <span class="keyword">local</span> toribio = <span class="global">require</span> <span class="string">'toribio'</span>

 M.start = <span class="keyword">function</span>(conf)
     sched.run(<span class="keyword">function</span>()
         <span class="keyword">local</span> file = <span class="global">io</span>.open(conf.outfile <span class="keyword">or</span> <span class="string">'data.log'</span>, <span class="string">'w'</span>)
         <span class="keyword">local</span> motor = toribio.wait_for_device(conf.motorname)
         <span class="keyword">while</span> <span class="keyword">true</span> <span class="keyword">do</span>
             <span class="keyword">local</span> l = motor:get_load()
             file:write(l..<span class="string">'\n'</span>)
             file:flush()
             sched.sleep(conf.interval <span class="keyword">or</span> <span class="number">5</span>)
         <span class="keyword">end</span>
     <span class="keyword">end</span>)
 <span class="keyword">end</span>

 <span class="keyword">return</span> M
</pre>

<p>The log file will contain motor load readings. The task (the function provided to sched.run) starts opening a file for writing and getting the Device for the specified motor. The wait_for_device call will block until the device is detected, so it is important to place that call <em>inside</em> the task (we do not want the main task blocking).</p>

<p>The task then will loop reading data from the motor and logging it, and then sleeping for the specified interval.</p>

<p>Notice how in the program we provide default values for configuration parameters in case they're missing (like a 5 second interval).</p>

<p>Finally, we run the program:</p>


<pre>
 lua toribio-go.lua
</pre>

<p><a name="Remote_controlled_robot"></a></p>
<h2>Remote controlled robot</h2>

<p>We will do a remote controlled robot. One instance of toribio will read inputs from the mouse, an generate commands over a UDP link to a Toribio instance in a robot with two motors (left and rigth).</p>

<h3>Remote Control</h3>

<p>We will need the mice device, and a task to process mice input and generate commands. We begin with the toribio-go.conf configuration file:</p>


<pre>
 deviceloaders.mice.<span class="global">load</span> = <span class="keyword">true</span>
 tasks.rc_control.<span class="global">load</span>=<span class="keyword">true</span>
 tasks.rc_control.ip=<span class="string">'127.0.0.1'</span> <span class="comment">--change with the ip adress of the robot
</span> tasks.rc_control.port=<span class="number">9999</span>
</pre>

<p>The remote control will behave as follows: it tracks mouse's movements, generates messages of the form "left, right" and sends them over udp. A message is sent at least each 0.5 seconds, so if we stop transmitting the robot can deduce it must stop. The skeleton for the tasks/rc_control.lua file is as follows:</p>


<pre>
 <span class="keyword">local</span> M = {}
 <span class="keyword">local</span> toribio = <span class="global">require</span> <span class="string">'toribio'</span>
 <span class="keyword">local</span> sched = <span class="global">require</span> <span class="string">'sched'</span>

 M.start = <span class="keyword">function</span>(conf)

     <span class="keyword">local</span> <span class="keyword">function</span> generate_output(x, y)
         <span class="comment">--calculate velocities and send them over udp
</span>     <span class="keyword">end</span>

     sched.run(<span class="keyword">function</span>()
         <span class="keyword">local</span> mice = toribio.wait_for_device(<span class="string">'mice:/dev/input/mice'</span>)
         <span class="keyword">local</span> lastx, lasty = <span class="number">0</span>, <span class="number">0</span>
         mice:register_callback(<span class="string">'move'</span>, <span class="keyword">function</span> (x, y)
             <span class="keyword">if</span> x <span class="keyword">then</span> 
                 generate_output(x, y)
                 lastx, lasty = x, y
             <span class="keyword">else</span>
                 <span class="comment">-- timeout with no mouse movements
</span>                 generate_output(lastx, lasty)
             <span class="keyword">end</span>
         <span class="keyword">end</span>, <span class="number">0.5</span>)
     <span class="keyword">end</span>)
 <span class="keyword">end</span>

 <span class="keyword">return</span> M
</pre>

<p>In this program we use the register_callback method, instead of the explicit loop with a sched.wait inside as in the first program. This will start yet another task (the one listening for the signal), that will keep runing while the first task (the one started with sched.run) will finish immediatelly. The register_callback method has a timeout parameter set (the 0.5 at the end). When the timeout runs out wihtout signals, it will wake our function with nil, 'timeout' as parameters: that's why we check for x to see wether we have a new coordinate, or must use the last recorded set of coordinates.</p>

<p>The only part missing is the generate_output function. We will use nixio to create a UDP socket and use it to send the messages.</p>


<pre>
 <span class="keyword">local</span> nixio = <span class="global">require</span> <span class="string">'nixio'</span>
 <span class="keyword">local</span> udp = <span class="global">assert</span>(nixio.bind(<span class="string">'*'</span>, <span class="number">0</span>, <span class="string">'inet'</span>, <span class="string">'dgram'</span>))
 udp:connect(conf.ip, conf.port)
 <span class="keyword">local</span> <span class="keyword">function</span> generate_output(x, y)
     <span class="keyword">local</span> left = (y + x)/<span class="number">2</span>
     <span class="keyword">local</span> right = (y - x)/<span class="number">2</span>
     udp:send(left..<span class="string">','</span>..right)
 <span class="keyword">end</span>
</pre>

<p>This program can be easily improved adding a callback that would react to mouse clicks. For example adding the following callback allows to stop the robot clicking the left button.</p>


<pre>
 mice:register_callback(<span class="string">'leftbutton'</span>, <span class="keyword">function</span> (is_pressed)
     <span class="keyword">if</span> is_pressed <span class="keyword">then</span> 
         generate_output(<span class="number">0</span>, <span class="number">0</span>)
         mice.reset_pos(<span class="number">0</span>, <span class="number">0</span>)
         lastx, lasty = <span class="number">0</span>, <span class="number">0</span>
     <span class="keyword">end</span>
 <span class="keyword">end</span>)
</pre>

<h3>Controlled bot</h3>

<p>The bot listens for UDP packets, parses them and set motor velocities. As allways, the configuration in toribio-go.conf:</p>


<pre>
 deviceloaders.dynamixel.<span class="global">load</span> = <span class="keyword">true</span>
 deviceloaders.dynamixel.filename = <span class="string">'/dev/ttyUSB0'</span>
 tasks.rc_bot.<span class="global">load</span> = <span class="keyword">true</span>
 tasks.rc_bot.ip = <span class="string">'127.0.0.1'</span> <span class="comment">--change with the ip adress of the robot
</span> tasks.rc_bot.port = <span class="number">9999</span>
 tasks.rc_bot.motor_left = <span class="string">'ax12:3'</span>
 tasks.rc_bot.motor_right = <span class="string">'ax12:12'</span>
</pre>

<p>And the tasks/rc_bot.lua skeleton:</p>


<pre>
 <span class="keyword">local</span> M = {}
 <span class="keyword">local</span> toribio = <span class="global">require</span> <span class="string">'toribio'</span>
 <span class="keyword">local</span> sched = <span class="global">require</span> <span class="string">'sched'</span>

 M.start = <span class="keyword">function</span>(conf)

     sched.run(<span class="keyword">function</span>()
         <span class="comment">--initialize motors
</span>         <span class="keyword">local</span> motor_left = toribio.wait_for_device(conf.motor_left)
         <span class="keyword">local</span> motor_right = toribio.wait_for_device(conf.motor_right)
         motor_left.init_mode_wheel()
         motor_right.init_mode_wheel()

         <span class="comment">--initialize socket
</span>         <span class="keyword">local</span> nixio = <span class="global">require</span> <span class="string">'nixio'</span>
         <span class="keyword">local</span> udp = <span class="global">assert</span>(nixio.bind(conf.ip, conf.port, <span class="string">'inet'</span>, <span class="string">'dgram'</span>))
         <span class="keyword">local</span> nixiorator = <span class="global">require</span> <span class="string">'tasks/nixiorator'</span>
         nixiorator.register_client(udp, <span class="number">1500</span>)

         <span class="comment">--listen for messages
</span>         sched.sigrun({emitter=nixiorator.task, events={udp}, timeout=<span class="number">1</span>}, 
             <span class="keyword">function</span>(_, _, msg) 
                 <span class="keyword">local</span> left, right = <span class="number">0</span>, <span class="number">0</span>
                 <span class="keyword">if</span> msg <span class="keyword">then</span>
                     left, right = msg:match(<span class="string">'^([^,]+),([^,]+)$'</span>)
                 <span class="keyword">end</span>
                 motor_left.set_speed(left)
                 motor_right.set_speed(right)
             <span class="keyword">end</span>
         )
     <span class="keyword">end</span>)
 <span class="keyword">end</span>

 <span class="keyword">return</span> M
</pre>

<p>Notice how we feed the socket to the nixiorator service (the nixiorator.register_client call), that will emit signals when data arrives. Then we listen for these signals with a function (registered in the sched.sigrun call). The timeout is set so if we do not receive a command within a second, the robot will stop.</p>

<p>Now we run toribio with rc_control task enabled on one machine, connected to a second machine with rc_bot enabled.</p>


<pre>
 lua toribio-go.lua
</pre>

<p>Notice that rc_control might have to be run as sudo, if your distribution request such thing for accesing /dev/input/mice.</p>

<p><a name="Reactive_line_follower"></a></p>
<h2>Reactive line follower</h2>

<p>TODO</p>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
